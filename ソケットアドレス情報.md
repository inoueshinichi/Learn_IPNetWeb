### 参考
+ http://www.02.246.ne.jp/~torutk/ipv6/socket.html
+ https://www.iajapan.org/ipv6/summit/KYOTO2013/pdf/Hiromi_Kyoto.pdf

### アドレスファミリ独立なソケットプログラミング
+ バイナリアドレスの格納(IPv4/IPv6)を格納する領域 : struct sockaddr_storage
+ IPv4アドレス用API : struct sockaddr_in *
+ IPv6アドレス用API : struct sockaddr_in6 *
+ バイナリアドレス情報を受け渡すAPI : struct sockaddr *

### 実際にソケットのためのアドレスを保持する構造体
+ struct sockaddr_in // IPv4
+ struct sockaddr_in6 // IPv6

### プログラミングの流れ
1. アドレスのバイナリ情報は, `struct sockaddr_storage`に格納する. 
2. アドレス情報を受け渡しする際は, 特定のプロトコル(IPv4/IPv6)に依存しない型`struct sockaddr *`を使う.
3.   `struct sockaddr_storage`の`ss_family`または`struct sockaddr *`の`sa_family`を`AF_INET`, `AF_INET6`で判別して, 本来の型(struct sockaddr_in, struct sockaddr_in6)にキャストして使用する.  

### アドレスファミリを読み取る
```
// アドレスのメモリ領域
struct sockaddr_storage address_memory;
// 共通アドレスAPI(インターフェース)
struct sockaddr* p_address = (struct sockaddr*)&address_memory;

if (p_address->sa_family == AF_INET)
{
	// IPv4用アドレスAPI(インターフェース)
	struct sockaddr_in* p_ipv4addr = (struct sockaddr_in*)p_address;
}
if (p_address->sa_family == AF_INET6)
{
	// IPv6用アドレスAPI(インターフェース)
	struct sockaddr_in6* p_ipv6addr = (struct sockaddr_in6*)p_address;
}
```


### バイナリアドレスのメモリ領域
```
// [Linux] sockaddr_storage
struct sockaddr_storage
{
	sa_family_t ss_family;
	char _sa_pad1[_SS_PAD1SIZE];
	sockaddr_maxalign_t _ss_align;
	char _ss_pad2[_SS_PAD2SIZE];
};

// [MacOS] sockaddr_storage
struct sockaddr_storage 
{
	__uint8_t        ss_len;         /* address length */
	sa_family_t     ss_family;      /* [XSI] address family */
	char                 __ss_pad1[_SS_PAD1SIZE];
	__int64_t         __ss_align;     /* force structure storage alignment */
	char                 __ss_pad2[_SS_PAD2SIZE];
};
```


### Linux (sockaddr, sockaddr_in, sockaddr_in6)
```
// [Linux] sockaddr
struct sockaddr
{
	sa_family_t sa_family; // アドレスファミリ
	char sa_data[14]; // 14バイト以内のプロトコルアドレス
};

// [Linux] in_addr
typedef uint16_t in_port_t;
typedef uint32_t in_addr_t;
struct in_addr
{
	in_addr_t s_addr;
};

// [Linux] sockaddr_in
struct sockaddr_in
{
	__SOCKADDR_COMMON(sin_);
	in_port_t sin_port; /* Port number. */
	struct in_addr sin_addr; /* Internet address. */
	
	/* Pad to size of `struct sockaddr`. */
	unsigned char sin_zero[sizeof (struct sockaddr) - 
	                                      __SOCKADDR_COMMON_SIZE -
	                                      sizeof (in_port_t) -
	                                      sizeof (struct in_addr)];
};

// [Linux] in6_addr
struct in6_addr
{
	unsigned char s6_addr[16]; /* IPv6 address */
};

// [Linux] sockaddr_in6
struct sockaddr_in6
{
	sa_family_t sin6_family; /* AF_INET6 */
	in_port_t sin6_port; /* port number */
	uint32_t sin6_flowinfo; /* IPv6 flow information */
	struct in6_addr sin6_addr; /* IPv6 address */
	uint32_t sin6_scope_id; /* Scope ID */
};
```


### MacOS (sockaddr, sockaddr_in, sockaddr_in6)
```
// [MacOS] sockaddr
struct sockaddr
{
	__uint8_t sa_len; /* total length */
	sa_family_t sa_family; /* address family */
#if __has_ptrcheck
	char sa_data[__counted_by(sa_len - 2)];
#else
	char sa_data[14];  /* addr value */
#endif
}; 

// [MacOS] in_addr
struct in_addr
{
	in_addr_t s_addr;
};

// [MacOS] sockaddr_in
struct sockaddr_in
{
	__uint8_t sin_len;
	sa_family_t sin_family;
	in_port_t sin_port;
	struct in_addr sin_addr;
	char sin_zero[8];
};

// [MacOS] in6_addr
typedef struct in6_addr
{
	union
	{
		__uint8_t    __u6_addr8[16];
		__uint16_t  __u6_addr16[8];
		__uint32_t  __u6_addr32[4];
	} __u6_addr; /* 128-bit IP6 address */
} in6_addr_t;

// [MacOS] sockaddr_in6
struct sockaddr_in6
{
	__uint8_t sin6_len; /* length of this struct(sa_family_t) */
	sa_family_t sin6_family; /* AF_INET6 */
	in_port_t sin6_port; /* Transport layer port */
	__uint32_t sin6_flowinfo; /* IP6 flow information */
	struct in6_addr sin6_addr; /* IP6 address */
	__uint32_t sin6_scope_id; /* scope zero index */
};
```


### 名前解決 FQDN --> IP Address 
```
struct addrinfo
{
	int ai_flags; // AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST
	int ai_family; // AF_[XX]
	int ai_socktype; // SOCK_[XX]
	int ai_protocol; // IPv4とIPv6に応じて`0`または`IPPROTO_[XX]`
	size_t ai_addrlen; // ai_addr長
	char* ai_canonname; // ノード名の正規名
	struct sockaddr* ai_addr; // バイナリアドレス
	struct addrinfo* ai_next; // バイナリアドレスの次の構造体 (リスト構造になっている)
};

int getaddrinfo(
	const char* hostname,
	const char* servname,
	const struct addrinfo* hints;
	struct addrinfo** res
);
```
+ hostnameかservnameどちらかはNULLでないことが必要.
+ hintsの条件にマッチしたaddrinfoのリストがresにセットされる.
+ DNS検索を避けるなら, `hints->ai_flags`にAI_NUMERICHOSTを指定する.
+ hostnameにNULLを指定すると, ループバックアドレス(`127.0.0.1`, `::1`)となる.
+ hostnameにNULLを指定し, 且つAI_PASSIVEを指定すると, ワイルドカードアドレスとなる.
+ スレッドセーフな関数.
+ 第4引数の`struct addrinfo** res`は, 内部でメモリ確保されるので, 使い終わった後は, `freeaddrinfo`でメモリを解放する.


#### 複数ソケットを処理するサーバーの流れ
1. getaddrinfo関数で, 自身のプロトコル・アドレスをaddrinfo構造体のリストで受け取る
+ hintsパラメータでAI_PASSIVEを指定すると, IN_ADDR_ANYとIN6ADDR_ANY_INITが得られる.
2. リストで得られたプロトコル・アドレス個別に下記を実施
+ socket, bind, listen
3. 得られた複数のファイルディスクリプタを`fd_set`構造体に保存
4. 以降はループ処理
+ fd_set構造体を引数にselect/pollで接続の待機
+ select/pollを抜けてきたfdに対してaccept
+ 読み書き処理
+ クローズ

#### サーバ側での使用例
```
char* port_of_self = "12345"; // サーバーポート文字列
struct addrinfo hints;
std::memset(&hints, 0, sizeof(hints));
hints.ai_socktype = SOCK_STREAM; // TCP socket
hints.ai_flags = AI_PASSIVE; // ワイルドカードアドレス

struct addrinfo res[1]; // リスト
int error = getaddrinfo(NULL, port_of_self, &hints, &res);
if (error)
{
	std::printf("[Error] port : %s.  %s\n", port_of_self, gai_strerror(error));
	return -1;
}

int passive_socket;
if ((passive_socket = socket(res[0]->ai_family, res[0]->ai_socktype, res[0]->ai_protocol) != 0)
{
	// ソケットエラー
}
```

### 旧APIの使用をやめる(非推奨)
+ プロトコル依存(IPv4依存)関数・構造体・マクロ
| 名前 | 機能 |
| :-- | :-- |
| inet_addr |  |
| inet_aton |  |
| inet_lnaof |  |
| inet_makeaddr |  |
| inet_netof |  |
| inet_network |  |
| inet_ntop |  |
| inet_pton |  |
| addr_ntoa |  |
| network |  |
| getservbyport |  |
| gethostbyname |  |
| gethostbyname2 |  |
| gethostbyaddr |  |
| getservbyname |  |
| struct in_addr |  |
| struct sockaddr_in |  |
| struct sockaddr | ? |
| rresvport |  |
| rcmd |  |
| INADDR_LOOPBACK |  |
| INADDR_ANY |  |
| IP_TTL |  |
| AF_INET |  |
| PF_INET |  |


### 推奨API
+ 非プロトコル依存
| 名前 | 機能 |
| :-- | :-- |
| struct sockaddr_storage | 汎用バイナリアドレス用ソケット構造体 |
| getaddrinfo | 名前解決(FQDN -> IP Address)用関数 |
| getnameinfo | アドレス解決(IP Address -> FQDN)用関数 |
| struct addinfo | 1インスタンスで1アドレスを持ち, リスト構造の1要素 |
| struct sockaddr | IPv4やIPv6等各種アドレス情報を汎化した構造体. 実体は, sockaddr_in6, sockaddr_in, どのアドレスが入るかわからない場合は, sockaddr_storageで定義する |

#### アドレス構造体の関係図(クラス図)
addrinfo   <--- sockaddr <----------- socaddr_storage
 |   ↑                                        |---- sockaddr_in 
 |---|                                         |---- sockaddr_in6
 
#### getaddrinfoのリスト構造
```
	res_ptr-> addrinfo[0] ----------> addrinfo[1] ----------> NULL    
	                |                                 |
                    sockaddr                   sockaddr
                    (sockaddr_in6)          (sockaddr_in)
                    --------------------         ----------------------
                    | IPv6アドレス |         | IPv4アドレス |
                    | ポート番号    |         | ポート番号     |
                    | etc...              |         | etc...               |
                    --------------------         ----------------------
```	




